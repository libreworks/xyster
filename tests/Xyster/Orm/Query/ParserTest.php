<?php
/**
 * Xyster Framework
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.opensource.org/licenses/bsd-license.php
 *
 * @category  Xyster
 * @package   UnitTests
 * @subpackage Xyster_Orm
 * @copyright Copyright (c) 2007-2008 Irrational Logic (http://irrationallogic.net)
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   $Id$
 */

// Call Xyster_Orm_Query_ParserTest::main() if this source file is executed directly.
if (!defined('PHPUnit_MAIN_METHOD')) {
    define('PHPUnit_MAIN_METHOD', 'Xyster_Orm_Query_ParserTest::main');
}

require_once dirname(dirname(__FILE__)) . '/TestSetup.php';
require_once 'Xyster/Orm/Query/Parser.php';

/**
 * Test class for Xyster_Orm_Query_Parser.
 * Generated by PHPUnit on 2008-02-05 at 18:04:27.
 */
class Xyster_Orm_Query_ParserTest extends Xyster_Orm_TestSetup
{
    /**
     * @var    Xyster_Orm_Query_Parser
     */
    protected $_parser;

    /**
     * Runs the test methods of this class.
     */
    public static function main()
    {
        require_once 'PHPUnit/TextUI/TestRunner.php';

        $suite  = new PHPUnit_Framework_TestSuite('Xyster_Orm_Query_ParserTest');
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Sets up the fixture
     */
    public function setUp()
    {
    	parent::setUp();
        $this->_parser = new Xyster_Orm_Query_Parser;
    }

    /**
     * Tests the 'parseCriterion' method
     *
     */
    public function testParseCriterion()
    {
        $result = $this->_parser->parseCriterion('( field1 = 123 AND field2 not LIKE "%something%" AND ( field3 BETWEEN "A" anD "Z" ) ) AND field3 > 5');
        
        $this->assertType('Xyster_Data_Junction', $result);
        $this->assertEquals(4, count(Xyster_Data_Criterion::getFields($result)));
        
        $result = $this->_parser->parseCriterion('field1 = 123 AND field2 not LIKE "%something%" AND field3 > 5');
        
        $this->assertType('Xyster_Data_Junction', $result);
        $this->assertEquals(3, count(Xyster_Data_Criterion::getFields($result)));
        
        $result = $this->_parser->parseCriterion('(field1 = 123 AND field2 not LIKE "%something%") AND field3 > 5');
        $this->assertType('Xyster_Data_Junction', $result);
        $this->assertEquals(3, count(Xyster_Data_Criterion::getFields($result)));
    }

    /**
     * Tests the 'parseCriterion' method with nested 'OR' junctions
     *
     */
    public function testParseCriterionWithSubs()
    {
        $result = $this->_parser->parseCriterion('( (username = "mmouse" OR username = "dduck" OR username = "goofy") AND (((country <> "United States" AND city = "Paris")) OR (country <> "Japan")) )');

        $this->assertType('Xyster_Data_Junction', $result);
        $this->assertEquals(6, count(Xyster_Data_Criterion::getFields($result)));
    }
    
    /**
     * Tests the 'parseCriterion' method with nested 'OR' junctions
     *
     */
    public function testParseCriterionWithSubsAndAggregates()
    {
        $result = $this->_parser->parseCriterion('( (max(username) = "mmouse" OR max(username) = "dduck" OR max(username) = "goofy") AND (((min(country) <> "United States" AND min(city) = "Paris")) OR (min(country) <> "Japan")) )');

        $this->assertType('Xyster_Data_Junction', $result);
        $this->assertEquals(6, count(Xyster_Data_Criterion::getFields($result)));
    }
    
    /**
     * Tests parsing an expression with a bad literal
     *
     */
    public function testParseExpressionBadLiteral()
    {
        $this->setExpectedException('Xyster_Orm_Query_Parser_Exception');
        $this->_parser->parseExpression('username > %aoeu!');
    }

    /**
     * Tests parsing an expression with a bad operator
     *
     */
    public function testParseExpressionBadOperator()
    {
        $this->setExpectedException('Xyster_Orm_Query_Parser_Exception');
        $this->_parser->parseExpression('username %%% "value"');
    }
    
    /**
     * Tests parsing an expression with a between operator and just one value
     *
     */
    public function testParseExpressionBetween()
    {
        $this->setExpectedException('Xyster_Orm_Query_Parser_Exception');
        $this->_parser->parseExpression('username BETWEEN "value"');
    }
    
    /**
     * Tests parsing an expression with an "in" operator
     *
     */
    public function testParseExpressionIn()
    {
        $result = $this->_parser->parseExpression('username NOT in ("mmouse", "dduck","goofy")');
        $this->assertType('Xyster_Data_Expression', $result);
        $this->assertSame(Xyster_Data_Operator_Expression::NotIn(), $result->getOperator());
        $this->assertEquals(array("mmouse","dduck", "goofy"), $result->getRight());
    }
    
    /**
     * Tests parsing an expression with a between operator and just one value
     *
     */
    public function testParseExpressionInBadValue()
    {
        $this->setExpectedException('Xyster_Orm_Query_Parser_Exception');
        $this->_parser->parseExpression('username in "value"');
    }
    
    /**
     * Tests the 'parseField' method
     *
     */
    public function testParseField()
    {
        $field = $this->_parser->parseField('myField');
        
        $this->assertType('Xyster_Data_Field', $field);
        $this->assertEquals('myField', $field->getName());
        
        $field = $this->_parser->parseField('MAX(createdOn)');
        $this->assertType('Xyster_Data_Field_Aggregate', $field);
        $this->assertEquals('createdOn', $field->getName());
        $this->assertEquals(Xyster_Data_Aggregate::Maximum(), $field->getFunction());
    }
    
    /**
     * Tests the 'parseFieldAlias' method
     *
     */
    public function testParseFieldAlias()
    {
        $field = $this->_parser->parseFieldAlias('myField as MyAlias');
        
        $this->assertType('Xyster_Data_Field', $field);
        $this->assertEquals('myField', $field->getName());
        $this->assertEquals('MyAlias', $field->getAlias());
        
        $field = $this->_parser->parseFieldAlias('username "UserNick"');
        
        $this->assertType('Xyster_Data_Field', $field);
        $this->assertEquals('username', $field->getName());
        $this->assertEquals('UserNick', $field->getAlias());
    }
    
    /**
     * Tests the 'parseQuery' method
     *
     */
    public function testParseQuery()
    {
        require_once 'Xyster/Orm/Query.php';
        $query = new Xyster_Orm_Query('MockBug', $this->_mockFactory()->getManager());
        $xsql = 'WHerE getCapitalOfNebraska() = "Lincoln" aND bugId > 0 ' 
            . 'ORDeR bY bugDescription asc LIMIT 5 OFFSET 0';
        $this->_parser->parseQuery($query, $xsql);
        
        $this->assertEquals(1, count($query->getWhere()));
        $this->assertEquals(1, count($query->getOrder()));
    }
    
    /**
     * Tests the 'parseReportQuery' method
     * 
     */
    public function testParseReportQuery()
    {
        require_once 'Xyster/Orm/Query/Report.php';
        $query = new Xyster_Orm_Query_Report('MockBug', $this->_mockFactory()->getManager());
        $xsql = 'SelecT DISTINCT reportedBy, count(bugId) as numOfBugs '
            . 'WHerE getCapitalOfNebraska() = "Lincoln" aND bugId > 0 ' 
            . 'GRoup By reportedBy '
            . 'HaVING count(bugId) > 0 '
            . 'ORDeR bY reportedBy asc LIMIT 5 OFFSET 0';
        $this->_parser->parseReportQuery($query, $xsql);
        
        $this->assertEquals(2, count($query->getFields()));
        $this->assertEquals(1, count($query->getGroup()));
        $this->assertEquals(1, count($query->getWhere()));
        $this->assertEquals(1, count($query->getOrder()));
        $this->assertEquals(1, count($query->getHaving()));
        $this->assertEquals(Xyster_Data_Expression::gt('count(bugId)', '0'), current($query->getHaving()));
    }

    /**
     * Tests the 'parseReportQuery' method with bad data
     *
     */
    public function testParseReportQueryBad()
    {
        require_once 'Xyster/Orm/Query/Report.php';
        $query = new Xyster_Orm_Query_Report('MockBug', $this->_mockFactory()->getManager());

        $this->setExpectedException('Xyster_Orm_Query_Parser_Exception');
        $this->_parser->parseReportQuery($query, 'doesnT start with "select"');
    }
    
    /**
     * Tests the 'parseSort' method
     *
     */
    public function testParseSort()
    {
        $sort = $this->_parser->parseSort('myField DESC');
        
        $this->assertType('Xyster_Data_Sort', $sort);
        $this->assertEquals('DESC', $sort->getDirection());
        $this->assertEquals('myField', $sort->getField()->getName());
    }
}

// Call Xyster_Orm_Query_ParserTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == 'Xyster_Orm_Query_ParserTest::main') {
    Xyster_Orm_Query_ParserTest::main();
}
