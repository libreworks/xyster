<?php
/**
 * Xyster Framework
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.opensource.org/licenses/bsd-license.php
 *
 * @category  Xyster
 * @package   UnitTests
 * @subpackage Xyster_Type
 * @copyright Copyright LibreWorks, LLC (http://libreworks.net)
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   $Id$
 */
namespace XysterTest\Type;
use Xyster\Type\Type;

/**
 * Test class for Xyster_Type.
 * Generated by PHPUnit on 2007-12-28 at 11:09:39.
 */
class TypeTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var    \Xyster\Type\Type
     */
    protected $object;

    const XYSTER_TYPE_CLASSNAME = '\Xyster\Type\Type';
    const XYSTER_TYPE_NAME = 'Xyster\Type\Type';

    /**
     * Sets up the fixture
     */
    protected function setUp()
    {
        $this->object = new Type(self::XYSTER_TYPE_CLASSNAME);
    }

    /**
     * Tests the constructor throws an exception for a bad type
     * @expectedException \Xyster\Type\Exception
     */
    public function testBadConstruct()
    {
        $object = new Type('aoeuhtns');
    }
    
    /**
     * Tests the 'equals' method
     */
    public function testEquals()
    {
        $other = new Type(self::XYSTER_TYPE_CLASSNAME);
        $other2 = new Type('\XysterTest\Type\TypeTest');
        $this->assertNotSame($this->object, $other);
        $this->assertTrue($this->object->equals($other));
        $this->assertFalse($this->object->equals($other2));
    }

    /**
     * Tests the 'getClass' method
     */
    public function testGetClass()
    {
        $class = $this->object->getClass();
        $this->assertType('\ReflectionClass', $class);
        $this->assertEquals('Xyster\Type\Type', $class->getName());
    }

    /**
     * Tests the 'getClass' method on a primitive type
     *
     */
    public function testGetClassOnPrimitive()
    {
        $object = new Type('array');
        $this->assertNull($object->getClass());
    }
    
    /**
     * Tests the 'getName' method
     */
    public function testGetName()
    {
        $this->assertSame(self::XYSTER_TYPE_NAME, $this->object->getName());
        $this->assertSame(self::XYSTER_TYPE_NAME, Type::of($this->object)->getName());
    }

    /**
     * Tests the 'getForParameters' method
     */
    public function testGetForParameters()
    {
    	$class = new \ReflectionClass('\XysterTest\Type\HashTest');
    	$params = Type::getForParameters($class->getMethod('testMethod'));
    	$this->assertEquals('ReflectionClass', $params[0]->getName());
    	$this->assertEquals('array', $params[1]->getName());
    	$this->assertEquals('scalar', $params[2]->getName());
        $this->assertEquals('ReflectionParameter', $params[3]->getName());
        $this->assertEquals('string', $params[4]->getName());
        $this->assertEquals('scalar', $params[5]->getName());
    }
    
    /**
     * Tests the 'hashCode' method
     */
    public function testHashCode()
    {
        $this->assertSame(Type::hash(self::XYSTER_TYPE_NAME), $this->object->hashCode());
    }

    /**
     * Tests the 'isAssignableFrom' method
     */
    public function testIsAssignableFrom()
    {
        $this->assertTrue($this->object->isAssignableFrom(self::XYSTER_TYPE_CLASSNAME), 'Failed on string class name');
        $this->assertTrue($this->object->isAssignableFrom($this->object->getClass()), 'Failed on ReflectionClass');
        $this->assertTrue($this->object->isAssignableFrom($this->object), 'Failed on itself');
        $this->assertTrue($this->object->isAssignableFrom(new Type(self::XYSTER_TYPE_CLASSNAME)), 'Failed on another \Xyster\Type\Type object');
        $this->assertFalse($this->object->isAssignableFrom(new Type('\XysterTest\Type\TypeTest')), 'Failed comparing to a different type');
    }

    /**
     * Tests the 'isObject' method
     */
    public function testIsObject()
    {
        $this->assertTrue($this->object->isObject());
    }
    
    /**
     * Tests the 'isObject' method on a primitive type
     */
    public function testIsObjectOnPrimitive()
    {
        $object = new Type('array');
        $this->assertFalse($object->isObject());
    }
    
    /**
     * Tests the '__toString' method
     */
    public function test__toString()
    {
        $this->assertEquals('Class Xyster\Type\Type', $this->object->__toString());
    }

    /**
     * Tests the 'areEqual' static method
     */
    public function testAreEqual()
    {
        $other = new Type(self::XYSTER_TYPE_CLASSNAME);
        $notequal = new Type('\XysterTest\Type\TypeTest');
        $object = new \stdClass;
        $object->test = 1234;
        $object2 = new \stdClass;
        $object2->test = 4567;
        $expected = array(
                array($this->object, $this->object, true),
                array($this->object, $other, true),
                array($this->object, $notequal, false),
                array(123, 123, true),
                array(123, 456, false),
                array('aoeu', 'aoeu', true),
                array('aoeu', 123, false),
                array(array(1), array(1), true),
                array(array(123), $object, false),
                array($object, 'aoeu', false),
                array($object, $this->object, false),
                array($object, $object2, false)
            );
        foreach( $expected as $array ) {
            $this->assertEquals($array[2], Type::areEqual($array[0], $array[1]),
                print_r($array[0], true) . ' equals ' . print_r($array[1], true) . ' should be ' . intval($array[2]));
        }
    }
    
    /**
     * Tests the 'areDeeplyEqual' static method
     */
    public function testAreDeeplyEqual()
    {
        $other = new Type(self::XYSTER_TYPE_CLASSNAME);
        $notequal = new Type('\XysterTest\Type\TypeTest');
        $object = new \stdClass;
        $object->foo = 'bar';
        $object->test = 1234;
        $object2 = new \stdClass;
        $object2->foo = 'baz';
        $object2->test = 4567;
        $object3 = new \stdClass;
        $object3->foo = 'bar';
        $object3->aoeu = 7890;
        $object4 = new \stdClass;
        $object4->foo = 'bar';
        $object4->test = 1234;
        $object4->aoeu = 7890;
        
        $a = new \stdClass;
        $b = new \stdClass;
        $a->obj = $b;
        $b->obj = $a;
        
        $expected = array(
                array($this->object, $this->object, true),
                array($this->object, $other, true),
                array($this->object, $notequal, false),
                array(123, 123, true),
                array(123, 456, false),
                array('aoeu', 'aoeu', true),
                array('aoeu', 123, false),
                array(array(1), array(1), true),
                array(array(123), $object, false),
                array($object, 'aoeu', false),
                array($object, $this->object, false),
                array($object, $object2, false),
                array($object, $object3, false),
                array($object, $object4, false),
                array($object, clone $object, true),
                array($a, $b, true)
            );
        foreach( $expected as $array ) {
            $this->assertEquals($array[2], Type::areDeeplyEqual($array[0], $array[1]),
                print_r($array[0], true) . ' equals ' . print_r($array[1], true) . ' should be ' . intval($array[2]));
        }
    }

    /**
     * Tests the static 'hash' method
     */
    public function testHash()
    {
        $test = $this->object->getClass();
        
        $max = (float)Type::INT_MAX_32;
        $min = (float)(0 - Type::INT_MAX_32);
        $h = 0;
        $hexArray = str_split(spl_object_hash($test), 2);
        foreach( $hexArray as $v ) {
            $result = 31 * $h + hexdec($v);
            if ( $result > $max ) {
                $h = $result % $max;
            } else if ( $result < $min ) {
                $h = 0-(abs($result) % $max);
            } else {
                $h = $result;
            }
        }
        
        $h2 = 0.0;
        foreach( $hexArray as $v ) {
            $result = 31 * $h2 + Type::hash($v);
            if ( $result > $max ) {
                $h2 = $result % $max;
            } else if ( $result < $min ) {
                $h2 = 0-(abs($result) % $max);
            } else {
                $h2 = $result;
            }
        }
        
        $expected = array(
                array(99162322, 'hello'),
                array(-1220935217, 'helloa'),
                array(-1821194164, 'hello to the world'),
                array(1333788668, (float)4294966296),
                array(1345844999, (float)12345678910),
                array(1123434234, 123.123),
                array(1231, true),
                array(1237, false),
                array(456789, 456789),
                array($h, $test),
                array($h2, $hexArray),
                array(1, new HashTest)
            );
        foreach( $expected as $array ) {
            $hash = Type::hash($array[1]);
            $this->assertType('integer', $hash);
            $this->assertEquals($array[0], $hash,
                'Hash for "' . print_r($array[1], true) . '" should be ' . $array[0]);
        }
    }
}

class HashTest
{
    public function testMethod( \ReflectionClass $class, array $items, $scalar, \ReflectionParameter $param = null, $default = 'test', $default2 = null )
    {
    }
    public function hashCode()
    {
        return 1;
    }
}
