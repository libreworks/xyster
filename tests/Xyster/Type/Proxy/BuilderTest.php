<?php
/**
 * Xyster Framework
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.opensource.org/licenses/bsd-license.php
 *
 * @category  Xyster
 * @package   UnitTests
 * @subpackage Xyster_Type
 * @copyright Copyright (c) 2007-2008 Irrational Logic (http://irrationallogic.net)
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   $Id$
 */
// Call Xyster_Type_Proxy_BuilderTest::main() if this source file is executed directly.
if (!defined('PHPUnit_MAIN_METHOD')) {
    define('PHPUnit_MAIN_METHOD', 'Xyster_Type_Proxy_BuilderTest::main');
}
require_once dirname(dirname(dirname(dirname(__FILE__)))) . DIRECTORY_SEPARATOR . 'TestHelper.php';
require_once 'Xyster/Type/Proxy/Builder.php';
require_once 'Xyster/Type.php';
require_once 'Xyster/Type/Proxy/Handler/Interface.php';

/**
 * Test class for Xyster_Type_Proxy_Builder.
 * Generated by PHPUnit on 2008-09-25 at 12:08:12.
 */
class Xyster_Type_Proxy_BuilderTest extends PHPUnit_Framework_TestCase
{
    /**
     * @var    Xyster_Type_Proxy_Builder
     */
    protected $object;

    /**
     * Runs the test methods of this class.
     */
    public static function main()
    {
        require_once 'PHPUnit/TextUI/TestRunner.php';
        $suite  = new PHPUnit_Framework_TestSuite('Xyster_Type_Proxy_BuilderTest');
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Sets up the fixture
     */
    protected function setUp()
    {
        $this->object = new Xyster_Type_Proxy_Builder;
    }

    /**
     * Tests the 'create' method
     */
    public function testCreate()
    {
        $interfaces = array(new Xyster_Type('ArrayAccess'),
            new Xyster_Type('IteratorAggregate'));
        $parent = new Xyster_Type('Xyster_Type_Proxy_BuilderTest_Foobar');
        $handler = $this->getMock('Xyster_Type_Proxy_Handler_Interface');
        $handler->expects($this->any())
            ->method('invoke')
            ->will($this->returnValue('bar!'));
        $this->object->setInterfaces($interfaces)
            ->setParent($parent)
            ->setCallParentConstructor(true)
            ->setHandler($handler);

        $obj = $this->object->create(array('asd'));
        $this->assertType('Xyster_Type_Proxy_BuilderTest_Foobar', $obj);
        $this->assertType('IteratorAggregate', $obj);
        $this->assertType('ArrayAccess', $obj);
        $this->assertType('Xyster_Type_Proxy_Interface', $obj);
        $this->assertAttributeEquals('asd', 'foo', $obj);
        $this->assertEquals('bar!', $obj->offsetGet('test123'));
    }

    /**
     * Tests the 'createType' method
     */
    public function testCreateType()
    {
        $interfaces = array(new Xyster_Type('ArrayAccess'),
            new Xyster_Type('IteratorAggregate'));
        $parent = new Xyster_Type('Xyster_Type_Proxy_BuilderTest_Foobar');
        $handler = $this->getMock('Xyster_Type_Proxy_Handler_Interface');
        $this->object->setInterfaces($interfaces)
            ->setParent($parent)
            ->setHandler($handler);
            
        $type = $this->object->createType();
        $this->assertType('Xyster_Type', $type);
        $proxyIface = new Xyster_Type('Xyster_Type_Proxy_Interface');
        $this->assertTrue($parent->isAssignableFrom($type));
        $this->assertTrue($interfaces[0]->isAssignableFrom($type));
        $this->assertTrue($interfaces[1]->isAssignableFrom($type));
        $this->assertTrue($proxyIface->isAssignableFrom($type));
        
        $type2 = $this->object->createType();
        $this->assertSame($type, $type2);
        Xyster_Type_Proxy_Builder::setCache(false);
        
        $type3 = $this->object->createType();
        $this->assertNotSame($type, $type3);
        Xyster_Type_Proxy_Builder::setCache(true);
    }

    /**
     * Tests the 'callParent' constructor method
     */
    public function testSetCallParentConstructor()
    {
        $return = $this->object->setCallParentConstructor(false);
        $this->assertSame($return, $this->object);
        $this->assertAttributeEquals(false, '_callConstructor', $this->object);
        $return = $this->object->setCallParentConstructor(true);
        $this->assertSame($return, $this->object);
        $this->assertAttributeEquals(true, '_callConstructor', $this->object);
    }

    /**
     * Tests the 'setHandler' method
     */
    public function testSetHandler()
    {
        $handler = $this->getMock('Xyster_Type_Proxy_Handler_Interface');
        $return = $this->object->setHandler($handler);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($handler, '_handler', $this->object);
    }

    /**
     * Tests the 'setInterfaces' method
     */
    public function testSetInterfaces()
    {
        $interfaces = array(new Xyster_Type('ArrayAccess'), new Xyster_Type('IteratorAggregate'));
        $return = $this->object->setInterfaces($interfaces);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($interfaces, '_interfaces', $this->object);
    }
    
    /**
     * Tests the 'setInterfaces' method with bad arguments
     */
    public function testSetInterfacesBad()
    {
        $interfaces = array(new Xyster_Type('ArrayObject'));
        $this->setExpectedException('Xyster_Type_Proxy_Exception', 'Not an interface: '.$interfaces[0]);
        $this->object->setInterfaces($interfaces);
    }

    /**
     * Tests the 'setParent' method
     */
    public function testSetParent()
    {
        $type = new Xyster_Type('ArrayObject');
        $return = $this->object->setParent($type);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($type, '_parent', $this->object);
    }

    /**
     * Tests the 'setCache' and 'usesCache' methods
     */
    public function testSetCache()
    {
        Xyster_Type_Proxy_Builder::setCache(false);
        $this->assertFalse(Xyster_Type_Proxy_Builder::usesCache());
        Xyster_Type_Proxy_Builder::setCache(true);
        $this->assertTrue(Xyster_Type_Proxy_Builder::usesCache());
    }
}

abstract class Xyster_Type_Proxy_BuilderTest_Foobar
{
    public $foo;
    
    public function __construct( $foo )
    {
        $this->foo = $foo;
    }
    
    final public function cantInherit()
    {
    }
    
    public function isTestMethod()
    {
    }
    
    abstract function abstractFunction();
}

// Call Xyster_Type_Proxy_BuilderTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == 'Xyster_Type_Proxy_BuilderTest::main') {
    Xyster_Type_Proxy_BuilderTest::main();
}
