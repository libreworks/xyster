<?php
/**
 * Xyster Framework
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.opensource.org/licenses/bsd-license.php
 *
 * @category  Xyster
 * @package   UnitTests
 * @subpackage Xyster_Type
 * @copyright Copyright LibreWorks, LLC (http://libreworks.net)
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @version   $Id$
 */
namespace XysterTest\Type\Proxy;
use Xyster\Type\Proxy\Builder;
/**
 * Test class for Xyster_Type_Proxy_Builder.
 * Generated by PHPUnit on 2008-09-25 at 12:08:12.
 */
class BuilderTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var    \Xyster\Type\Proxy\Builder
     */
    protected $object;

    /**
     * Sets up the fixture
     */
    protected function setUp()
    {
        $this->object = new Builder;
    }

    /**
     * Tests the 'create' method
     */
    public function testCreate()
    {
        $interfaces = array(new \Xyster\Type\Type('\ArrayAccess'),
            new \Xyster\Type\Type('\IteratorAggregate'));
        $parent = new \Xyster\Type\Type('\XysterTest\Type\Proxy\BuilderTest_Foobar');
        $handler = $this->getMock('\Xyster\Type\Proxy\IHandler');
        $handler->expects($this->any())
            ->method('invoke')
            ->will($this->returnValue('bar!'));
        $this->object->setInterfaces($interfaces)
            ->setParent($parent)
            ->setCallParentConstructor(true)
            ->setHandler($handler);

        $obj = $this->object->create(array('asd'));
        $this->assertType('\XysterTest\Type\Proxy\BuilderTest_Foobar', $obj);
        $this->assertType('\IteratorAggregate', $obj);
        $this->assertType('\ArrayAccess', $obj);
        $this->assertType('\Xyster\Type\Proxy\IProxy', $obj);
        $this->assertAttributeEquals('asd', 'foo', $obj);
        $this->assertEquals('bar!', $obj->offsetGet('test123'));
    }

    /**
     * Tests the 'createType' method
     */
    public function testCreateType()
    {
        $interfaces = array(new \Xyster\Type\Type('\ArrayAccess'),
            new \Xyster\Type\Type('\IteratorAggregate'));
        $parent = new \Xyster\Type\Type('\XysterTest\Type\Proxy\BuilderTest_Foobar');
        $handler = $this->getMock('\Xyster\Type\Proxy\IHandler');
        $this->object->setInterfaces($interfaces)
            ->setParent($parent)
            ->setHandler($handler);
            
        $type = $this->object->createType();
        $this->assertType('\Xyster\Type\Type', $type);
        $proxyIface = new \Xyster\Type\Type('\Xyster\Type\Proxy\IProxy');
        $this->assertTrue($parent->isAssignableFrom($type));
        $this->assertTrue($interfaces[0]->isAssignableFrom($type));
        $this->assertTrue($interfaces[1]->isAssignableFrom($type));
        $this->assertTrue($proxyIface->isAssignableFrom($type));
        
        $type2 = $this->object->createType();
        $this->assertSame($type, $type2);
        Builder::setCache(false);
        
        $type3 = $this->object->createType();
        $this->assertNotSame($type, $type3);
        Builder::setCache(true);
    }

    /**
     * Tests the 'callParent' constructor method
     */
    public function testSetCallParentConstructor()
    {
        $return = $this->object->setCallParentConstructor(false);
        $this->assertSame($return, $this->object);
        $this->assertAttributeEquals(false, '_callConstructor', $this->object);
        $return = $this->object->setCallParentConstructor(true);
        $this->assertSame($return, $this->object);
        $this->assertAttributeEquals(true, '_callConstructor', $this->object);
    }

    /**
     * Tests the 'setHandler' method
     */
    public function testSetHandler()
    {
        $handler = $this->getMock('\Xyster\Type\Proxy\IHandler');
        $return = $this->object->setHandler($handler);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($handler, '_handler', $this->object);
    }

    /**
     * Tests the 'setInterfaces' method
     */
    public function testSetInterfaces()
    {
        $interfaces = array(new \Xyster\Type\Type('\ArrayAccess'), new \Xyster\Type\Type('\IteratorAggregate'));
        $return = $this->object->setInterfaces($interfaces);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($interfaces, '_interfaces', $this->object);
    }
    
    /**
     * Tests the 'setInterfaces' method with bad arguments
     * @expectedException \Xyster\Type\Proxy\ProxyException
     */
    public function testSetInterfacesBad()
    {
        $interfaces = array(new \Xyster\Type\Type('\ArrayObject'));
        $this->object->setInterfaces($interfaces);
    }

    /**
     * Tests the 'setParent' method
     */
    public function testSetParent()
    {
        $type = new \Xyster\Type\Type('\ArrayObject');
        $return = $this->object->setParent($type);
        $this->assertSame($return, $this->object);
        $this->assertAttributeSame($type, '_parent', $this->object);
    }

    /**
     * Tests the 'setCache' and 'usesCache' methods
     */
    public function testSetCache()
    {
        Builder::setCache(false);
        $this->assertFalse(Builder::usesCache());
        Builder::setCache(true);
        $this->assertTrue(Builder::usesCache());
    }
}

abstract class BuilderTest_Foobar
{
    public $foo;
    
    public function __construct( $foo )
    {
        $this->foo = $foo;
    }
    
    final public function cantInherit()
    {
    }
    
    public function isTestMethod()
    {
    }
    
    abstract function abstractFunction();
}
